# Написать функцию email_parse(<email_address>), которая при помощи регулярного выражения
# извлекает имя пользователя и почтовый домен из email адреса и возвращает их в виде словаря.
#
# Техническое задание:
#     Функция:
#         1. принимает один параметр: строку с email
#         2. извлекает имя пользователя - то, что до @ и домен - то, что после @
#         3. возвращает словарь вида {'username': <имя_пользователя>, 'domain': <домен>}
#     2. Если адрес не валиден, выбросить исключение ValueError. Можно с сообщением вида «wrong email: <email_address>»
#     3. Шаблон имени пользователя: латинские буквы, цифры и символы: ' . _ + -
#     4. Шаблон домена: латинские буквы, цифры и символы . -
#     5. В домене обязательно должна быть хотя бы одна точка
#     6. Не использовать функцию split, теперь только регулярные выражения
#     7. email полностью парсится за «один проход». Используйте группы.
#     8. Чтобы проверить работоспособность функции на разных данных, вам придется «ловить» исключение в основной программе и выводить сообщение.
#     9. Проверьте работоспособность функции на нескольких email. Обязательно на правильных и неправильных.
#
# Примечание:
#     1. Подумайте о возможных ошибках в адресе и постарайтесь учесть их в регулярном выражении
#     2. Имеет ли смысл в данном случае использовать функцию re.compile()?
#     3. Не используйте слишком широкий шаблон для почты. Шаблон должен пропускать только то, что указано в условии
#     4. Подумайте, сколько групп здесь используется?

import re

def email_parse(email_address):
    data = re.compile(r'(^[A-z0-9\'._+-]{1,})@([A-z0-9.-]{1,}.[A-z]{2,})')
    email = data.findall(email_address)
    if email:
        output = dict()
        output['username'] = email[0][0]
        output['domain'] = email[0][1]
        return output
    else:
        msg = f'wrong email: {email_address}'
        raise ValueError(msg)
